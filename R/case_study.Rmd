---
title: "Single-cell Gene Regulatory Network Analysis using Joint Random Forest"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: flatly
    df_print: paged
    toc: yes
    toc_float: yes
    fig_width: 12
    fig_height: 8
    fig_retina: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 12,
  fig.height = 8,
  dpi = 300,
  fig.retina = 2
)
knitr::opts_knit$set(root.dir = "~/Desktop/scGraphVerse/")
```

# Abstract

This analysis demonstrates the application of scGraphVerse package for inferring gene networks from scRNA-seq data of peripheral blood mononuclear cells (PBMCs). 

# Introduction

Gene networks (GNs) provide crucial insights into cellular function and disease mechanisms. Here, we apply the Joint Random Forest (JRF) algorithm to infer robust GNs from PBMC data.

## Load Libraries and Data

```{r libraries, message=FALSE, warning=FALSE}
library(RColorBrewer)
library(DT)
library(scGraphVerse)
library(tidyverse)
library(Seurat)
library(viridis)
library(patchwork)
library(scales)
library(igraph)
library(org.Hs.eg.db)

library(tidygraph)
library(ggraph)
library(circlize)

theme_publication <- theme_minimal() +
  theme(
    text = element_text(size = 12, family = "sans"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10),
    strip.text = element_text(size = 11, face = "bold"),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  )

theme_set(theme_publication)

results_dir <- "./analysis/casestudy/results"
plots_dir <- file.path(results_dir, "plots")
tables_dir <- file.path(results_dir, "tables")

if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
if (!dir.exists(tables_dir)) dir.create(tables_dir, recursive = TRUE)

seurat_subset_filt <- readRDS("./analysis/casestudy/PBMC.top600.RDS")

# Data summary
cat("Dataset Summary:\n")
cat("Number of cells:", ncol(seurat_subset_filt), "\n")
cat("Number of genes:", nrow(seurat_subset_filt), "\n")
cat("Number of donors:", length(unique(seurat_subset_filt$SAMPLE_ID)), "\n")

```

# Methods

## Data Preprocessing

```{r data-split}
seurat_split <- SplitObject(
  object = seurat_subset_filt,
  split.by = "SAMPLE_ID"
)

cat("Data split into", length(seurat_split), "donor-specific datasets\n")
donor_summary <- sapply(seurat_split, ncol) %>% 
  data.frame(Cells = .) %>%
  rownames_to_column("Donor")

write.csv(donor_summary, file.path(tables_dir, "cells_per_donor.csv"), row.names = FALSE)

knitr::kable(donor_summary, caption = "Cells per donor")
```

## Joint Random Forest Network Inference

```{r jrf-inference, cache=TRUE}
set.seed(1234)
cat("Inferring networks using Joint Random Forest...\n")
start_time <- Sys.time()

# Convert seurat_split list to MultiAssayExperiment
mae_data <- create_mae(seurat_split)

jrf_mat <- infer_networks(mae_data,
                          method = "JRF")

end_time <- Sys.time()
cat("Network inference completed in", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")
```

## Network Processing and Consensus Generation

```{r network-processing}
# generate_adjacency returns a SummarizedExperiment
jrf_wadj_se <- generate_adjacency(jrf_mat)
sjrf_wadj_se <- symmetrize(jrf_wadj_se, weight_function = "mean")

cat("Generated", length(SummarizedExperiment::assays(sjrf_wadj_se)), "weighted adjacency matrices\n")
cat("Matrix dimensions:", nrow(SummarizedExperiment::assays(sjrf_wadj_se)[[1]]), "x", ncol(SummarizedExperiment::assays(sjrf_wadj_se)[[1]]), "\n")
```

```{r cutoff-adjacency, cache=TRUE}
set.seed(1234)
cat("Applying statistical cutoffs to adjacency matrices...\n")

# cutoff_adjacency expects MultiAssayExperiment and SummarizedExperiment, returns SummarizedExperiment
sjrf_adj_se <- cutoff_adjacency(count_matrices = mae_data,
                                weighted_adjm_list = sjrf_wadj_se,
                                n = 2,
                                method = "JRF")

# Summary statistics - extract assays from SummarizedExperiment
sjrf_adj_list <- SummarizedExperiment::assays(sjrf_adj_se)
edge_counts <- sapply(sjrf_adj_list, function(x) sum(x > 0) / 2)
cat("Edges per network after cutoff:\n")
print(summary(edge_counts))
```

## Step 2: Consensus Network Generation

```{r consensus-network}
set.seed(1234)
# Create consensus network using vote method
consensus_net_se <- create_consensus(sjrf_adj_se, method = "vote")

# Extract the consensus matrix for analysis
consensus_net <- SummarizedExperiment::assays(consensus_net_se)[[1]]

cat("Consensus network statistics:\n")
cat("Nodes:", nrow(consensus_net), "\n")
cat("Edges:", sum(consensus_net > 0) / 2, "\n")
cat("Density:", round(sum(consensus_net > 0) / (nrow(consensus_net) * (nrow(consensus_net) - 1)), 4), "\n")
```

# Results

## Step 3: Consensus Network Visualization

```{r plot-consensus, fig.width=14, fig.height=10}
# Visualize the consensus network using scGraphVerse plotg()
cat("Visualizing consensus network...\n")
set.seed(1234)
p_consensus <- plotg(consensus_net_se)

# Save the plot
ggsave(file.path(plots_dir, "consensus_network.png"), p_consensus,
       width = 14, height = 10, dpi = 300, bg = "white")
ggsave(file.path(plots_dir, "consensus_network.pdf"), p_consensus,
       width = 14, height = 10, bg = "white")

print(p_consensus)
```

## Step 4: Community Detection

```{r community-detection}
# Detect communities in the consensus network
set.seed(1234)
comm_results <- community_path(consensus_net_se, plot = TRUE, verbose = FALSE)

network_graph <- comm_results$graph
membership <- comm_results$communities$membership

# Analyze community structure
community_sizes <- table(membership)
cat("Community detection results:\n")
cat("Total communities identified:", length(community_sizes), "\n")
cat("Community size distribution:\n")
print(summary(as.numeric(community_sizes)))

# Create community summary table
community_summary <- data.frame(
  Community = names(community_sizes),
  Size = as.numeric(community_sizes),
  Percentage = round(as.numeric(community_sizes) / sum(community_sizes) * 100, 2)
) %>%
  arrange(desc(Size))

#write.csv(community_summary, file.path(tables_dir, "community_summary.csv"), row.names = FALSE)

knitr::kable(head(community_summary, 10),
             caption = "Top 10 largest communities by gene count")
```

## Step 5: Community Network Visualization

```{r plot-communities, fig.width=14, fig.height=10}
# Filter for large communities and visualize
min_community_size <- 71
large_communities <- community_sizes[community_sizes >= min_community_size]
valid_communities <- as.integer(names(large_communities))

cat("Visualizing", length(valid_communities), "communities with ≥", min_community_size, "genes\n")

# Filter the consensus network to include only genes in large communities
valid_genes <- names(membership)[membership %in% valid_communities]
filtered_consensus <- consensus_net[valid_genes, valid_genes]

# Visualize filtered network with scGraphVerse
set.seed(12345)
p_communities <- community_path(filtered_consensus)

# Save the plot
#ggsave(file.path(plots_dir, "network_communities.png"), p_communities,
#       width = 14, height = 10, dpi = 300, bg = "white")
#ggsave(file.path(plots_dir, "network_communities.pdf"), p_communities,
#       width = 14, height = 10, bg = "white")

print(p_communities)
```



```{r}

g <- graph_from_adjacency_matrix(filtered_consensus, 
                                 mode = "undirected", 
                                 weighted = TRUE,
                                 diag = FALSE)

V(g)$community <- membership[V(g)$name]

top3_communities <- names(sort(table(V(g)$community), decreasing = TRUE)[1:3])
g_top3 <- induced_subgraph(g, V(g)$community %in% top3_communities)

community_colors <- setNames(
  c("#E41A1C", "#377EB8", "#4DAF4A"),
  top3_communities
)

set.seed("4321")
p_network <- ggraph(g_top3, layout = "fr") +
  geom_edge_link(aes(alpha = weight), edge_colour = "grey70", 
                 show.legend = FALSE) +
  geom_node_point(aes(color = as.factor(community)), size = 3) +
  scale_color_manual(values = community_colors, name = "Community") +
  theme_void() +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 25, face = "bold"),  
        legend.text = element_text(size = 25),                   
        legend.key.size = unit(1.5, "cm"))

```


```{r}
pathway_results <- comm_results$pathways
pathway_results_top3 <- pathway_results[top3_communities]

sapply(pathway_results_top3, function(x) {
  if(is.null(x)) return(0)
  nrow(x)
})

filter_specific_pathways <- function(pathway_results, community_names, pval_cutoff = 0.05) {
  
  all_pathways <- lapply(community_names, function(comm) {
    pw_res <- pathway_results[[comm]]
    if(is.null(pw_res) || nrow(pw_res) == 0) return(NULL)
    
    pw_res <- as.data.frame(pw_res)
    pw_sig <- pw_res[pw_res$p.adjust < pval_cutoff, ]
    
    if(nrow(pw_sig) == 0) return(NULL)
    
    data.frame(
      Community = comm,
      ID = pw_sig$ID,
      Description = pw_sig$Description,
      p.adjust = pw_sig$p.adjust,
      Count = pw_sig$Count,
      geneID = pw_sig$geneID,
      FoldEnrichment = pw_sig$FoldEnrichment,
      category = pw_sig$category,
      subcategory = pw_sig$subcategory,
      stringsAsFactors = FALSE
    )
  })
  
  all_pathways_df <- do.call(rbind, all_pathways[!sapply(all_pathways, is.null)])
  
  pathway_frequency <- all_pathways_df %>%
    dplyr::group_by(ID) %>%
    dplyr::summarise(
      n_communities = dplyr::n(),
      Description = dplyr::first(Description),  # FIX QUI
      .groups = "drop"
    )
  
  specific_pathway_ids <- pathway_frequency %>%
    dplyr::filter(n_communities == 1) %>%
    dplyr::pull(ID)
  
  for(comm in community_names) {
    comm_pathways <- all_pathways_df %>% dplyr::filter(Community == comm)
    comm_specific <- comm_pathways %>% dplyr::filter(ID %in% specific_pathway_ids)
    cat("Community", comm, "- Total:", nrow(comm_pathways), 
        "| Specific:", nrow(comm_specific), "\n")
  }
  
  return(list(
    all_pathways = all_pathways_df,
    specific_pathway_ids = specific_pathway_ids,
    pathway_frequency = pathway_frequency
  ))
}

pathway_filtering <- filter_specific_pathways(pathway_results_top3, 
                                               top3_communities, 
                                               pval_cutoff = 0.05)

specific_pathway_ids <- pathway_filtering$specific_pathway_ids

prepare_pathway_bubble <- function(pathway_results, community_names, 
                                   specific_ids = NULL, top_n = 10) {
  
  pathway_list <- lapply(community_names, function(comm) {
    
    pw_res <- pathway_results[[comm]]
    
    if(is.null(pw_res) || nrow(pw_res) == 0) {
      cat("No paths for community", comm, "\n")
      return(NULL)
    }
    
    pw_res <- as.data.frame(pw_res)
    
    if(!is.null(specific_ids)) {
      pw_res <- pw_res[pw_res$ID %in% specific_ids, ]
      cat("Community", comm, "- After filtering:", nrow(pw_res), "specific pathways\n")
      
      if(nrow(pw_res) == 0) {
        cat("No specific pathways for community", comm, "\n")
        return(NULL)
      }
    }
    
    pw_res <- pw_res[order(pw_res$p.adjust), ]
    pw_top <- head(pw_res, top_n)
    
    pw_top$Community <- as.character(comm)
    pw_top$neg_log_pval <- -log10(pw_top$p.adjust)
    
    pw_top$Description_short <- ifelse(
      nchar(as.character(pw_top$Description)) > 50,
      paste0(substr(pw_top$Description, 1, 47), "..."),
      as.character(pw_top$Description)
    )
    
    cat("Community", comm, "- Selected for plot:", nrow(pw_top), "pathways\n")
    
    return(pw_top)
  })
  
  pathway_df <- do.call(rbind, pathway_list[!sapply(pathway_list, is.null)])
  
  if(is.null(pathway_df) || nrow(pathway_df) == 0) {
    stop("No specific pathways to plot!")
  }
  
  return(pathway_df)
}

pathway_df <- prepare_pathway_bubble(pathway_results_top3, 
                                     top3_communities, 
                                     specific_ids = specific_pathway_ids, 
                                     top_n = 10)

p_bubble <- ggplot(pathway_df, 
                   aes(x = Community, 
                       y = reorder(Description_short, neg_log_pval),
                       size = Count,
                       color = p.adjust)) +
  geom_point(alpha = 0.75) +
  scale_color_gradient(low = "lightblue", high = "darkblue", 
                       name = "Adjusted\np-value",
                       trans = "log10") +
  scale_size_continuous(range = c(3, 10), 
                        name = "Gene Count",
                        breaks = c(5, 10, 15, 20)) +
  labs(x = "Communities", 
       y = NULL,
       title = "Community-Specific Enriched Pathways",
       subtitle = "Pathways significantly enriched in only one community") +
  theme_minimal(base_size = 11) +
  theme(
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 11),
    strip.background = element_rect(fill = "grey95", color = NA),
    panel.grid.major.y = element_line(color = "grey90"),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(fill = NA, color = "grey80"),
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10, color = "grey40")
  ) +
  facet_wrap(~Community, scales = "free_y", ncol = 1)

p_bubble_combined <- ggplot(pathway_df, 
                            aes(x = Community, 
                                y = reorder(Description_short, neg_log_pval),
                                size = Count,
                                color = p.adjust)) +
  geom_point(alpha = 0.7) +
  scale_color_gradient(low = "lightblue", high = "darkblue", 
                       name = "Adjusted p-value",
                       trans = "log10") +
  scale_size_continuous(range = c(3, 10), name = "Gene Count") +
  labs(x = "Communities", 
       y = NULL,
       title = "Community-Specific Enriched Pathways",
       subtitle = "Only pathways unique to each community") +
  theme_minimal(base_size = 25) +
  theme(
    axis.text.y = element_text(size = 25),
    axis.text.x = element_text(size = 25),
    legend.position = "right",
    legend.box = "vertical",
    legend.direction = "vertical",
    panel.grid.major.y = element_line(color = "grey90"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 25),
    plot.subtitle = element_text(size = 25, color = "grey40")
  ) +
  guides(
    color = guide_colorbar(order = 1),
    size = guide_legend(order = 2, override.aes = list(color = "black"))
  )

combined_horizontal <- p_network | p_bubble_combined + 
  plot_layout(widths = c(1, 1.3))
print(combined_horizontal)

ggsave("community_specific_pathways_horizontal.png", 
       combined_horizontal, 
       width = 30, height = 15, 
       dpi = 300,
       device = "png")

```

## External Validation and Literature Support

```{r stringdb-validation, fig.width=12, fig.height=8}

cat("Validating network edges against STRING database...\n")

string_adj <- stringdb_adjacency(
    genes = rownames(consensus_net),
    species = 9606,
    required_score = 900,
    keep_all_genes = TRUE
  )


string_binary <- string_adj$binary
string_adj_sym <- string_binary[rownames(consensus_net), rownames(consensus_net)]

```

## Literature Mining and Edge Support

```{r pubmed-mining}
cat("Performing literature 
    mining for edge validation...\n")

set.seed("1234")
pubmed_results <- edge_mining(list(consensus_net), string_adj_sym, query_edge_types = "FP")

pubmed_enriched <- pubmed_results[[1]] %>%
  mutate(
    gene1_community = comm_results$communities$membership[gene1],
    gene2_community = comm_results$communities$membership[gene2]
  ) %>%
  rowwise() %>%
  mutate(
    gene1_pathways = if (!is.na(gene1_community)) {
      pathway_obj <- comm_results$pathways[[as.character(gene1_community)]]
      if (!is.null(pathway_obj) && nrow(pathway_obj@result) > 0) {
        paste(pathway_obj@result$Description, collapse = "; ")
      } else {
        NA_character_
      }
    } else {
      NA_character_
    },
    gene2_pathways = if (!is.na(gene2_community)) {
      pathway_obj <- comm_results$pathways[[as.character(gene2_community)]]
      if (!is.null(pathway_obj) && nrow(pathway_obj@result) > 0) {
        paste(pathway_obj@result$Description, collapse = "; ")
      } else {
        NA_character_
      }
    } else {
      NA_character_
    }
  ) %>%
  ungroup()

target_communities <- c(3, 7, 9)
genes_in_communities <- names(comm_results$communities$membership)[
  comm_results$communities$membership %in% target_communities
]

genes_long <- pubmed_enriched %>%
  filter(gene1 %in% genes_in_communities | gene2 %in% genes_in_communities) %>%
  pivot_longer(
    cols = c(gene1, gene2),
    names_to = "gene_position",
    values_to = "gene"
  ) %>%
  filter(gene %in% genes_in_communities) %>%
  mutate(
    community = ifelse(gene_position == "gene1", gene1_community, gene2_community),
    pathways = ifelse(gene_position == "gene1", gene1_pathways, gene2_pathways)
  ) %>%
  select(gene, community, pathways, pubmed_hits) %>%
  distinct() %>%
  unnest(pathways)

top_genes_by_community <- genes_long %>%
  group_by(community, gene) %>%
  summarise(
    total_pubmed_hits = sum(pubmed_hits, na.rm = TRUE),
    n_pathways = n_distinct(pathways, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(community) %>%
  arrange(community, desc(total_pubmed_hits)) %>%
  slice_head(n = 10) %>%  # Cambia n per avere più o meno geni
  ungroup()

top_unique_genes_by_community <- top_genes_by_community %>%
  semi_join(
    data.frame(
      gene = names(p_communities$communities$membership),
      community = p_communities$communities$membership
    ) %>%
      group_by(gene) %>%
      filter(n() == 1) %>%
      ungroup(),
    by = "gene"
  )
```


```{r}
pathways_of_interest <- list(
  "3" = c("Regulation of actin cytoskeleton", "Tight junction"),
  "7" = c("Mitophagy - animal", "Measies"),
  "9" = c("Protein export", "Protein processing in endoplasmic reticulum")
)

top_interactions_custom <- lapply(c(3, 7, 9), function(comm) {
  
  cat("\n--- Processing Community", comm, "---\n")
  
  pathway_obj <- comm_results$pathways[[as.character(comm)]]
  
  if (is.null(pathway_obj) || nrow(pathway_obj@result) == 0) {
    return(NULL)
  }
  
  selected_pathways <- pathway_obj@result %>%
    dplyr::filter(Description %in% pathways_of_interest[[as.character(comm)]])
  
  if (nrow(selected_pathways) == 0) {
    cat("No matching pathways found for community", comm, "\n")
    cat("Available pathways:\n")
    print(pathway_obj@result$Description)
    return(NULL)
  }
  
  cat("Selected pathways:", paste(selected_pathways$Description, collapse = ", "), "\n")
  
  genes_in_selected_pathways <- unique(unlist(strsplit(
    paste(selected_pathways$geneID, collapse = "/"), 
    "/"
  )))
  
  gene_symbols <- clusterProfiler::bitr(genes_in_selected_pathways, 
                       fromType = "ENTREZID", 
                       toType = "SYMBOL", 
                       OrgDb = org.Hs.eg.db,
                       drop = TRUE)$SYMBOL
  
  cat("Genes in selected pathways:", length(gene_symbols), "\n")
  
  pathway_interactions <- pubmed_enriched %>%
    dplyr::select(-gene1_pathways, -gene2_pathways) %>%
    dplyr::filter(
      gene1 %in% gene_symbols & 
      gene2 %in% gene_symbols &
      gene1_community == comm & 
      gene2_community == comm
    ) %>%
    dplyr::arrange(desc(pubmed_hits))
  
  cat("Interactions found:", nrow(pathway_interactions), "\n")
  
  if (nrow(pathway_interactions) == 0) {
    cat("No interactions with both genes. Trying with at least one gene...\n")
    
    housekeeping <- c("GAPDH", "ACTB", "ACTG1", "EEF1A1", "EEF2", "PPIA", 
                      "RACK1", "FTL", "PFN1", "TUBB", "TUBA1B")
    
    pathway_interactions <- pubmed_enriched %>%
      dplyr::select(-gene1_pathways, -gene2_pathways) %>%
      dplyr::filter(
        (gene1 %in% gene_symbols | gene2 %in% gene_symbols) &
        (gene1_community == comm | gene2_community == comm) &
        !gene1 %in% housekeeping &
        !gene2 %in% housekeeping
      ) %>%
      dplyr::arrange(desc(pubmed_hits))
    
    cat("Interactions (at least one gene, no housekeeping):", nrow(pathway_interactions), "\n")
  }
  
  if (nrow(pathway_interactions) == 0) {
    return(NULL)
  }
  
  top_n <- min(5, nrow(pathway_interactions))
  
  lapply(1:top_n, function(i) {
    top <- pathway_interactions[i, ]
    data.frame(
      community = comm,
      rank = i,
      selected_pathways = paste(selected_pathways$Description, collapse = " | "),
      gene1 = top$gene1,
      gene2 = top$gene2,
      interaction = paste(top$gene1, "--", top$gene2),
      edge_type = top$edge_type,
      citations = top$pubmed_hits,
      gene1_in_pathway = top$gene1 %in% gene_symbols,
      gene2_in_pathway = top$gene2 %in% gene_symbols
    )
  }) %>% dplyr::bind_rows()
})

top_interactions_custom <- dplyr::bind_rows(top_interactions_custom)

print(top_interactions_custom)

```


## Session Information

```{r session-info}
sessionInfo()
```





