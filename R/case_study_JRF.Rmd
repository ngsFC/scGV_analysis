---
title: "Single-cell Gene Regulatory Network Analysis using Joint Random Forest"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: flatly
    df_print: paged
    toc: yes
    toc_float: yes
    fig_width: 12
    fig_height: 8
    fig_retina: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 12,
  fig.height = 8,
  dpi = 300,
  fig.retina = 2
)
knitr::opts_knit$set(root.dir = "~/Desktop/scGraphVerse/")
```

# Abstract

This analysis demonstrates the application of scGraphVerse package for inferring gene regulatory networks from scRNA-seq data of peripheral blood mononuclear cells (PBMCs). 

# Introduction

Gene regulatory networks (GRNs) provide crucial insights into cellular function and disease mechanisms. scRNA-seq enables the reconstruction of these networks at unprecedented resolution. Here, we apply the Joint Random Forest (JRF) algorithm to infer robust GRNs from PBMC data.

## Load Libraries and Data

```{r libraries, message=FALSE, warning=FALSE}
library(RColorBrewer)
library(DT)
library(scGraphVerse)
library(tidyverse)
library(Seurat)
library(viridis)
library(patchwork)
library(scales)

library(tidygraph)
library(ggraph)
library(pheatmap)
library(ComplexHeatmap)
library(circlize)

theme_publication <- theme_minimal() +
  theme(
    text = element_text(size = 12, family = "sans"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10),
    strip.text = element_text(size = 11, face = "bold"),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  )

theme_set(theme_publication)

results_dir <- "./analysis/casestudy/results"
plots_dir <- file.path(results_dir, "plots")
tables_dir <- file.path(results_dir, "tables")

if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
if (!dir.exists(tables_dir)) dir.create(tables_dir, recursive = TRUE)

seurat_subset_filt <- readRDS("./analysis/casestudy/PBMC.top600.RDS")

# Data summary
cat("Dataset Summary:\n")
cat("Number of cells:", ncol(seurat_subset_filt), "\n")
cat("Number of genes:", nrow(seurat_subset_filt), "\n")
cat("Number of donors:", length(unique(seurat_subset_filt$SAMPLE_ID)), "\n")

```

# Methods

## Data Preprocessing

```{r data-split}
seurat_split <- SplitObject(
  object = seurat_subset_filt,
  split.by = "SAMPLE_ID"
)

cat("Data split into", length(seurat_split), "donor-specific datasets\n")
donor_summary <- sapply(seurat_split, ncol) %>% 
  data.frame(Cells = .) %>%
  rownames_to_column("Donor")

write.csv(donor_summary, file.path(tables_dir, "cells_per_donor.csv"), row.names = FALSE)

knitr::kable(donor_summary, caption = "Cells per donor")
```

## Joint Random Forest Network Inference

```{r jrf-inference, cache=TRUE}
set.seed(1234)
cat("Inferring networks using Joint Random Forest...\n")
start_time <- Sys.time()

jrf_mat <- infer_networks(seurat_split, 
                          method = "JRF")

end_time <- Sys.time()
cat("Network inference completed in", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")
```

## Network Processing and Consensus Generation

```{r network-processing}
jrf_wadj <- generate_adjacency(jrf_mat)
sjrf_wadj <- symmetrize(jrf_wadj, weight_function = "mean")

cat("Generated", length(sjrf_wadj), "weighted adjacency matrices\n")
cat("Matrix dimensions:", nrow(sjrf_wadj[[1]]), "x", ncol(sjrf_wadj[[1]]), "\n")
```

```{r cutoff-adjacency, cache=TRUE}
set.seed(1234)
cat("Applying statistical cutoffs to adjacency matrices...\n")

sjrf_adj <- cutoff_adjacency(count_matrices = seurat_split,
                             weighted_adjm_list = sjrf_wadj, 
                             n = 2,
                             method = "JRF",
                             nCores = 15)

# Summary statistics
edge_counts <- sapply(sjrf_adj, function(x) sum(x > 0) / 2)
cat("Edges per network after cutoff:\n")
print(summary(edge_counts))
```

```{r consensus-network}
consensus_net <- create_consensus(sjrf_adj, method = "vote")

cat("Consensus network statistics:\n")
cat("Nodes:", nrow(consensus_net), "\n")
cat("Edges:", sum(consensus_net > 0) / 2, "\n")
cat("Density:", round(sum(consensus_net > 0) / (nrow(consensus_net) * (nrow(consensus_net) - 1)), 4), "\n")
```


# Results

## Community Detection and Network Analysis

```{r community-detection, fig.width=16, fig.height=12}
comm_results <- community_path(consensus_net)

network_graph <- comm_results$graph
membership <- comm_results$communities$membership

# Analyze community structure
community_sizes <- table(membership)
cat("Community detection results:\n")
cat("Total communities identified:", length(community_sizes), "\n")
cat("Community size distribution:\n")
print(summary(as.numeric(community_sizes)))

# Create community summary table
community_summary <- data.frame(
  Community = names(community_sizes),
  Size = as.numeric(community_sizes),
  Percentage = round(as.numeric(community_sizes) / sum(community_sizes) * 100, 2)
) %>%
  arrange(desc(Size))

write.csv(community_summary, file.path(tables_dir, "community_summary.csv"), row.names = FALSE)

knitr::kable(head(community_summary, 10), 
             caption = "Top 10 largest communities by gene count")
```

## Publication-Quality Network Visualization

```{r network-viz, fig.width=14, fig.height=10}
ùmin_community_size <- 60
large_communities <- community_sizes[community_sizes >= min_community_size]
valid_communities <- as.integer(names(large_communities))

valid_vertices <- names(membership)[membership %in% valid_communities]

filtered_graph <- igraph::induced_subgraph(network_graph, vids = valid_vertices)
tg <- as_tbl_graph(filtered_graph)

tg <- tg %>%
  mutate(
    community = factor(membership[name]),
    degree = igraph::degree(filtered_graph),
    betweenness = igraph::betweenness(filtered_graph, normalized = TRUE)
  )

set.seed(1234)
p1 <- ggraph(tg, layout = "fr", 
             niter = 3000,
             area = vcount(tg)^2.3,
             repulserad = vcount(tg)^2.6,
             coolexp = 1.5,
             maxdelta = vcount(tg)) +
  geom_edge_link(alpha = 0.4, color = "grey70", width = 0.3) +
  geom_node_point(aes(color = community, size = degree), alpha = 0.8) +
  scale_color_viridis_d(name = "Community", option = "plasma") +
  scale_size_continuous(name = "Degree", range = c(1, 4)) +
  labs(
    title = "Gene Regulatory Network Communities",
    subtitle = paste("Showing communities with ≥", min_community_size, "genes"),
    caption = "Node size represents degree centrality"
  ) +
  theme_void() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    legend.position = "right",
    legend.box = "vertical",
    panel.background = element_rect(fill = "white", color = NA)
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 3)),
    size = guide_legend(override.aes = list(color = "black"))
  )

print(p1)

ggsave(file.path(plots_dir, "network_communities.png"), p1, 
       width = 14, height = 10, dpi = 300, bg = "white")
ggsave(file.path(plots_dir, "network_communities.pdf"), p1, 
       width = 14, height = 10, bg = "white")
```

## Network Topology Analysis

```{r network-topology, fig.width=12, fig.height=8}
network_stats <- list(
  nodes = vcount(filtered_graph),
  edges = ecount(filtered_graph),
  density = edge_density(filtered_graph),
  transitivity = transitivity(filtered_graph),
  diameter = diameter(filtered_graph),
  avg_path_length = average.path.length(filtered_graph),
  modularity = modularity(filtered_graph, membership[V(filtered_graph)$name])
)

# Create summary table
stats_df <- data.frame(
  Metric = c("Nodes", "Edges", "Density", "Clustering Coefficient", 
             "Diameter", "Average Path Length", "Modularity"),
  Value = c(network_stats$nodes, network_stats$edges, 
            round(network_stats$density, 4), round(network_stats$transitivity, 3),
            network_stats$diameter, round(network_stats$avg_path_length, 2),
            round(network_stats$modularity, 3))
)

write.csv(stats_df, file.path(tables_dir, "network_topology_metrics.csv"), row.names = FALSE)

knitr::kable(stats_df, caption = "Network topology metrics")

degree_data <- data.frame(
  gene = V(filtered_graph)$name,
  degree = degree(filtered_graph),
  community = factor(membership[V(filtered_graph)$name])
)

p2 <- ggplot(degree_data, aes(x = degree)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
  geom_vline(xintercept = mean(degree_data$degree), color = "red", linetype = "dashed", size = 1) +
  labs(
    title = "Degree Distribution",
    x = "Degree",
    y = "Frequency",
    caption = paste("Mean degree =", round(mean(degree_data$degree), 2))
  ) +
  theme_publication

p3 <- ggplot(degree_data, aes(x = community, y = degree, fill = community)) +
  geom_boxplot(alpha = 0.7, outlier.alpha = 0.5) +
  scale_fill_viridis_d(option = "plasma") +
  labs(
    title = "Degree Distribution by Community",
    x = "Community",
    y = "Degree"
  ) +
  theme_publication +
  theme(legend.position = "none")

combined_plot <- p2 / p3
print(combined_plot)

ggsave(file.path(plots_dir, "degree_distribution.png"), combined_plot, 
       width = 12, height = 8, dpi = 300, bg = "white")
ggsave(file.path(plots_dir, "degree_distribution.pdf"), combined_plot, 
       width = 12, height = 8, bg = "white")

write.csv(degree_data, file.path(tables_dir, "degree_data.csv"), row.names = FALSE)
```


## Functional Pathway Enrichment Analysis

```{r pathway-prep}
selected_communities <- names(community_sizes[community_sizes >= min_community_size])

pathway_df <- bind_rows(
  lapply(selected_communities, function(comm) {
    if (!is.null(comm_results$pathways[[comm]]) && nrow(comm_results$pathways[[comm]]) > 0) {
      df <- as.data.frame(comm_results$pathways[[comm]])
      df$Community <- paste0("Community ", comm)
      df$Community_ID <- comm
      return(df)
    }
    return(NULL)
  })
)


if (nrow(pathway_df) > 0) {
  pathway_df <- pathway_df %>%
    filter(p.adjust < 0.05) %>%
    arrange(p.adjust)
  
  cat("Pathway enrichment summary:\n")
  cat("Total significant pathways:", nrow(pathway_df), "\n")
  cat("Communities with enriched pathways:", length(unique(pathway_df$Community)), "\n")
  
  write.csv(pathway_df, file.path(tables_dir, "pathway_enrichment.csv"), row.names = FALSE)
}
```

```{r pathway-visualization, fig.width=14, fig.height=12}
if (nrow(pathway_df) > 0) {
  top_pathways <- pathway_df %>%
    group_by(Community) %>%
    slice_min(p.adjust, n = 8) %>%
    ungroup() %>%
    mutate(
      Description = str_wrap(Description, width = 50),
      log10_padj = -log10(p.adjust),
      Community = factor(Community, levels = paste0("Community ", sort(as.numeric(selected_communities))))
    )
  
  p4 <- ggplot(top_pathways, aes(x = Community, y = reorder(Description, log10_padj))) +
    geom_point(aes(size = Count, color = log10_padj), alpha = 0.8) +
    scale_color_viridis_c(name = "-log10(adj. p-value)", option = "plasma", direction = 1) +
    scale_size_continuous(name = "Gene Count", range = c(2, 8), guide = guide_legend(order = 2)) +
    labs(
      title = "Pathway Enrichment Analysis by Community",
      subtitle = "Top enriched KEGG pathways",
      x = "Community",
      y = "KEGG Pathway"
    ) +
    theme_minimal() +  
    theme(
      text = element_text(size = 12),  
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.text.y = element_text(size = 9),
      legend.position = "right",
      legend.box = "vertical",
      panel.grid.major.x = element_line(color = "grey90"),
      panel.grid.major.y = element_line(color = "grey95")
    ) +
    guides(
      color = guide_colorbar(order = 1, barwidth = 1, barheight = 8),
      size = guide_legend(order = 2, override.aes = list(color = "black"))
    )

  
  print(p4)
  
ggsave(file.path(plots_dir, "pathway_enrichment_bubble.png"), p4,
         width = 14, height = 12, dpi = 300, bg = "white", device = "png", type = "cairo")
ggsave(file.path(plots_dir, "pathway_enrichment_bubble.pdf"), p4,
         width = 14, height = 12, bg = "white", device = "pdf")

write.csv(top_pathways, file.path(tables_dir, "top_pathways.csv"), row.names = FALSE)
  
  top_pathways_table <- top_pathways %>%
    select(Community, Description, Count, p.adjust) %>%
    arrange(Community, p.adjust) %>%
    mutate(p.adjust = scientific(p.adjust, digits = 3))
  
  write.csv(top_pathways_table, file.path(tables_dir, "top_pathways_table.csv"), row.names = FALSE)
  
  knitr::kable(head(top_pathways_table, 20), 
               caption = "Top 20 enriched pathways across communities",
               col.names = c("Community", "Pathway", "Gene Count", "Adj. p-value"))
  
} else {
  cat("No significant pathway enrichments found (p.adjust < 0.05)\n")
}
```

## External Validation and Literature Support

```{r stringdb-validation, fig.width=12, fig.height=8}
cat("Validating network edges against STRING database...\n")

string_adj <- stringdb_adjacency(
    genes = rownames(consensus_net),
    species = 9606,
    required_score = 900,
    keep_all_genes = TRUE
  )


string_binary <- string_adj$binary
string_binary <- string_binary[rownames(consensus_net), rownames(consensus_net)]
string_adj_sym <- symmetrize(list(string_binary), weight_function = "mean")[[1]]

our_edges <- which(consensus_net > 0, arr.ind = TRUE)
our_edges <- our_edges[our_edges[,1] < our_edges[,2], ] # Upper triangle only

string_edges <- which(string_adj_sym > 0, arr.ind = TRUE)
string_edges <- string_edges[string_edges[,1] < string_edges[,2], ] # Upper triangle only

our_edge_set <- paste(our_edges[,1], our_edges[,2], sep = "_")
string_edge_set <- paste(string_edges[,1], string_edges[,2], sep = "_")

overlap <- length(intersect(our_edge_set, string_edge_set))
precision <- overlap / length(our_edge_set)
recall <- overlap / length(string_edge_set)
f1_score <- 2 * (precision * recall) / (precision + recall)

validation_metrics <- data.frame(
  Metric = c("Total JRF Edges", "Total STRING Edges", "Overlapping Edges", 
             "Precision", "Recall", "F1 Score"),
  Value = c(length(our_edge_set), length(string_edge_set), overlap,
            round(precision, 3), round(recall, 3), round(f1_score, 3))
)

write.csv(validation_metrics, file.path(tables_dir, "validation_metrics.csv"), row.names = FALSE)

validation_plot_data <- data.frame(
  Category = c("JRF Only", "STRING Only", "Both"),
  Count = c(length(our_edge_set) - overlap, 
            length(string_edge_set) - overlap, 
            overlap)
)

p6 <- ggplot(validation_plot_data, aes(x = Category, y = Count, fill = Category)) +
  geom_col(alpha = 0.8, color = "black") +
  scale_fill_viridis_d(option = "plasma") +
  labs(
    title = "Edge Overlap: JRF vs STRING Database",
    y = "Number of Edges",
    x = "Edge Category"
  ) +
  theme_publication +
  theme(legend.position = "none") +
  geom_text(aes(label = Count), vjust = -0.5, fontface = "bold")

print(p6)

ggsave(file.path(plots_dir, "string_validation.png"), p6, 
       width = 12, height = 8, dpi = 300, bg = "white")
ggsave(file.path(plots_dir, "string_validation.pdf"), p6, 
       width = 12, height = 8, bg = "white")

write.csv(validation_plot_data, file.path(tables_dir, "validation_plot_data.csv"), row.names = FALSE)
```

## Literature Mining and Edge Support

```{r pubmed-mining}
cat("Performing literature 
    mining for edge validation...\n")

pubmed_results <- edge_mining(list(consensus_net), string_adj_sym, query_edge_types = "FP")

target_communities <- as.numeric(selected_communities)
community_genes <- lapply(target_communities, function(comm) {
  names(membership)[membership == comm]
})
names(community_genes) <- paste0("Community_", target_communities)

if (length(pubmed_results) > 0 && !is.null(pubmed_results[[1]])) {
  query_df <- pubmed_results[[1]]
  
  filtered_edges_by_community <- lapply(names(community_genes), function(name) {
    genes <- community_genes[[name]]
    edges <- query_df %>%
      filter(gene1 %in% genes & gene2 %in% genes & pubmed_hits > 0) %>%
      arrange(desc(pubmed_hits))
    return(edges)
  })
  names(filtered_edges_by_community) <- names(community_genes)
  
  literature_summary <- data.frame(
    Community = names(filtered_edges_by_community),
    Total_Edges = sapply(filtered_edges_by_community, nrow),
    High_Support = sapply(filtered_edges_by_community, function(x) sum(x$pubmed_hits > 20)),
    Medium_Support = sapply(filtered_edges_by_community, function(x) sum(x$pubmed_hits > 10 & x$pubmed_hits <= 20))
  ) %>%
    mutate(Percentage_Supported = round((High_Support + Medium_Support) / Total_Edges * 100, 1))
  
  write.csv(literature_summary, file.path(tables_dir, "literature_summary.csv"), row.names = FALSE)
  
  knitr::kable(literature_summary, 
               caption = "Literature support for community edges",
               col.names = c("Community", "Total Edges", "High Support (>50)", 
                           "Medium Support (10-50)", "% Supported"))
  
  if (any(literature_summary$Total_Edges > 0)) {
    top_supported_edges <- bind_rows(
      lapply(names(filtered_edges_by_community), function(comm) {
        edges <- filtered_edges_by_community[[comm]]
        if (nrow(edges) > 0) {
          head(edges, 5) %>%
            mutate(Community = comm) %>%
            select(Community, gene1, gene2, pubmed_hits)
        }
      })
    )
    
    if (nrow(top_supported_edges) > 0) {
      write.csv(top_supported_edges, file.path(tables_dir, "top_supported_edges.csv"), row.names = FALSE)
      
      knitr::kable(top_supported_edges, 
                   caption = "Top literature-supported edges per community",
                   col.names = c("Community", "Gene 1", "Gene 2", "PubMed Hits"))
    }
  }
  
} else {
  cat("No PubMed mining results available\n")
}
```

## Key Findings

```{r summary-statistics}
summary_results <- list(
  total_genes = nrow(consensus_net),
  total_edges = sum(consensus_net > 0) / 2,
  communities = length(community_sizes),
  large_communities = length(community_sizes[community_sizes >= min_community_size]),
  network_density = round(sum(consensus_net > 0) / (nrow(consensus_net) * (nrow(consensus_net) - 1)), 4),
  modularity = round(modularity(network_graph, membership), 3)
)

cat("## Summary of Network Analysis Results\n\n")
cat("- **Total genes analyzed:", summary_results$total_genes, "**\n")
cat("- **Network edges identified:", summary_results$total_edges, "**\n") 
cat("- **Communities detected:", summary_results$communities, "**\n")
cat("- **Large communities (≥10 genes):", summary_results$large_communities, "**\n")
cat("- **Network density:", summary_results$network_density, "**\n")
cat("- **Modularity score:", summary_results$modularity, "**\n\n")

if (exists("validation_metrics")) {
  cat("- **STRING database validation:**\n")
  cat("  - Precision:", validation_metrics$Value[validation_metrics$Metric == "Precision"], "\n")
  cat("  - Recall:", validation_metrics$Value[validation_metrics$Metric == "Recall"], "\n")
  cat("  - F1 Score:", validation_metrics$Value[validation_metrics$Metric == "F1 Score"], "\n\n")
}

if (exists("pathway_df") && nrow(pathway_df) > 0) {
  cat("- **Pathway enrichment:** ", nrow(pathway_df), "significant pathways identified\n")
}

write.table(as.data.frame(summary_results), "results_cases.txt", col.names = T, row.names = F, sep = "\t", quote = F)
```

## Session Information

```{r session-info}
sessionInfo()
```





